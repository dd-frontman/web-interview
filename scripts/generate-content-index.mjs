import fs from "node:fs";
import path from "node:path";
import {
	collectMarkdownFiles,
	escapeTsString,
	inferDescription,
	inferTags,
	inferTitle,
	isValidIsoDate,
	routeFromFilePath,
	splitFrontmatter,
	toPosix,
} from "./lib/content-utils.mjs";

const cwd = process.cwd();
const outputPath = path.join(cwd, ".vitepress", "theme", "generated", "content-index.ts");

function normalizeTags(route, value) {
	if (Array.isArray(value)) {
		const tags = value.map((item) => (typeof item === "string" ? item.trim() : "")).filter(Boolean);
		if (tags.length > 0) {
			return Array.from(new Set(tags)).slice(0, 8);
		}
	}
	return inferTags(route);
}

function serializeArray(values) {
	if (values.length === 0) {
		return "[]";
	}
	return `[${values.map((item) => `"${escapeTsString(item)}"`).join(", ")}]`;
}

const files = collectMarkdownFiles();
const entries = [];

for (const filePath of files) {
	const route = routeFromFilePath(filePath);
	if (route === "/index") {
		continue;
	}

	const source = fs.readFileSync(filePath, "utf8");
	const { frontmatter, body } = splitFrontmatter(source);

	const title =
		typeof frontmatter.title === "string" && frontmatter.title.trim()
			? frontmatter.title.trim()
			: inferTitle(route, body);
	const description =
		typeof frontmatter.description === "string" && frontmatter.description.trim()
			? frontmatter.description.trim()
			: inferDescription(body, title);
	const tags = normalizeTags(route, frontmatter.tags);
	const updatedAt = isValidIsoDate(frontmatter.updatedAt)
		? frontmatter.updatedAt
		: new Date().toISOString().slice(0, 10);
	const hasManualRelated = /<RelatedTopics[\s\S]*?\/>/.test(body);
	const search = frontmatter.search === false ? false : true;

	entries.push({
		route,
		title,
		description,
		tags,
		updatedAt,
		hasManualRelated,
		search,
		source: toPosix(path.relative(cwd, filePath)),
	});
}

entries.sort((a, b) => a.route.localeCompare(b.route));

const fileContent = `/* eslint-disable */
// This file is auto-generated by scripts/generate-content-index.mjs.
// Do not edit manually.

export type ContentIndexItem = {
	route: string;
	title: string;
	description: string;
	tags: string[];
	updatedAt: string;
	hasManualRelated: boolean;
	search: boolean;
	source: string;
};

export const contentIndex: ContentIndexItem[] = [
${entries
	.map(
		(entry) =>
			`\t{
\t\troute: "${escapeTsString(entry.route)}",
\t\ttitle: "${escapeTsString(entry.title)}",
\t\tdescription: "${escapeTsString(entry.description)}",
\t\ttags: ${serializeArray(entry.tags)},
\t\tupdatedAt: "${escapeTsString(entry.updatedAt)}",
\t\thasManualRelated: ${entry.hasManualRelated},
\t\tsearch: ${entry.search},
\t\tsource: "${escapeTsString(entry.source)}",
\t}`
	)
	.join(",\n")}
];
`;

fs.mkdirSync(path.dirname(outputPath), { recursive: true });
fs.writeFileSync(outputPath, fileContent, "utf8");

console.log(
	`Content index generated: ${path.relative(cwd, outputPath)} (${entries.length} entries).`
);
