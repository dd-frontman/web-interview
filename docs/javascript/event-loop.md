## Event Loop

- это концепция, лежащая в основе асинхронного программирования, которая позволяет JavaScript выполнять неблокирующие операции, несмотря на то, что сам язык является однопоточным.
  В общем виде, Event Loop, или цикл событий, следует следующим этапам:

1. **Call Stack (Стек вызовов)**: Это место, где выполняется ваш JavaScript код. Когда функция вызывается, она помещается на вершину стека вызовов. Когда функция завершена, она удаляется из стека.
2. **Web APIs** — это набор асинхронных API браузера, которые **выполняются вне JavaScript-движка**, а результаты их работы возвращаются в Event Loop через очереди задач.
3. **Callback Queue (Очередь обратного вызова)**: Это список задач, которые ожидают выполнения. Когда асинхронная функция завершает свою работу (например, Ajax-запрос, таймер и т.д.), она добавляет новую задачу в очередь.

Сам Event Loop делает следующее:

1. Проверяет, есть ли в стеке вызовов какие-либо функции для выполнения. Если есть, он запускает их одну за другой, пока стек не опустеет.
2. Когда стек пуст, он смотрит на очередь задач. Если в очереди есть задачи, Event Loop берет первую задачу из очереди и помещает ее в стек вызовов для выполнения.
3. Этот процесс повторяется бесконечно, вот почему это называется "циклом событий".

```javascript
console.log("Start"); // 1

setTimeout(function () {
	console.log("Timeout 1"); // 5
}, 0);

Promise.resolve()
	.then(function () {
		console.log("Promise 1"); // 3
	})
	.then(function () {
		console.log("Promise 2"); // 4
	});

console.log("End"); // 2
```

### Микро-таски

Микро-таски — это задачи, которые выполняются сразу после текущего события в Event Loop, но перед перерисовкой DOM или выполнением следующего макро-таска. Примеры:

1. **Promise.then()**: Коллбеки, переданные в `Promise.then()`, добавляются в очередь микро-таск.
   ```javascript
   Promise.resolve().then(() => console.log("This is a micro-task"));
   ```
2. **queueMicrotask()**: Явное добавление микро-таска.
   ```javascript
   queueMicrotask(() => console.log("Another micro-task"));
   ```
3. **MutationObserver**: Используется для отслеживания изменений в DOM и выполняет коллбеки как микро-таски.
   ```javascript
   const observer = new MutationObserver(() => {
   	console.log("DOM mutated");
   });
   ```

### Макро-таски

Макро-таски — это задачи, которые добавляются в очередь макро-таск и выполняются одна за другой. Примеры:

1. **setTimeout() и setInterval()**: Эти функции добавляют коллбеки в очередь макро-таск.
   ```javascript
   setTimeout(() => console.log("This is a macro-task"), 0);
   ```
2. **I/O операции**: Например, чтение файла в Node.js.
   ```javascript
   const fs = require("fs");
   fs.readFile("/path/to/file", (err, data) => {
   	console.log("File read");
   });
   ```
3. **UI рендеринг**: Обновление пользовательского интерфейса также является макро-таской.
4. **Запросы AJAX**: Они также добавляются в очередь макро-таск.

## **Правила очередности:**

### **1. Сначала выполняется основной (синхронный) код.**

---

### **2. После основного кода ВСЕ микротаски (microtasks) из очереди.**

- Микротаски:
  - `.then()` и `.catch()` у промисов
  - `queueMicrotask()`
  - `MutationObserver`
- Все микротаски выполняются до первой макротаски, даже если внутри микротаски создаются новые микротаски.

---

### **3. После микротасок — ОДНА макротаска (macrotask) из очереди.**

- Макротаски:
  - `setTimeout`
  - `setInterval`
  - `setImmediate` (Node.js)
  - события DOM, I/O, message events

---

### **4. После выполнения макротаски — снова ВСЕ микротаски (если они появились во время макротаски).**

---

### **5. Потом следующая макротаска → снова микротаски → и так далее.**

## **Алгоритм-правило:**

1. Выполни весь синхронный код.
2. Выполни все микротаски из очереди.
   - Если в процессе появились новые микротаски, продолжай выполнять их, пока очередь не пуста.
3. Возьми первую макротаску из очереди и выполни её.
4. После макротаски — снова все микротаски.
5. Повторяй шаги 3–4, пока есть задачи.
