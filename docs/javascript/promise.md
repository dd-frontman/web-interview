## **Что такое promises в JavaScript?**

**Промис** (Promise) — это специальный объект в JavaScript для работы с асинхронными операциями (например, запросами к серверу, таймерами, чтением файлов и т.п.), чтобы управлять результатом “в будущем”.

Промис — это “контейнер” для результата асинхронной операции, который может быть:

- **Ожидание (pending)** — операция ещё не завершена.
- **Исполнен (fulfilled)** — операция завершилась успешно, есть результат.
- **Отклонён (rejected)** — операция завершилась с ошибкой.
  Ты “обещаешь”, что результат будет **позже**, а код продолжает работать.

```js
const promise = new Promise((resolve, reject) => {
	// Например, симуляция задержки
	setTimeout(() => {
		if (Math.random() > 0.5) resolve("Успех!");
		else reject("Ошибка!");
	}, 1000);
});
```

- **resolve** — вызываем, если всё хорошо (переходит в fulfilled).
- **reject** — вызываем, если ошибка (переходит в rejected).

#### **Promise — синтаксис “снаружи” и “внутри”**

**Внутри промиса**
Ты используешь функцию-конструктор и вручную вызываешь resolve/reject.
**Снаружи промиса**
Ты работаешь с готовым промисом: навешиваешь then/catch/finally.

#### **Как обрабатывать результат промиса**

1. **then** — если всё ок

```js
promise.then((result) => {
	console.log("Всё хорошо:", result);
});
```

2. **catch** — если ошибка

```js
promise.catch((error) => {
	console.log("Произошла ошибка:", error);
});
```

3. **finally** — всегда

```js
promise.finally(() => {
	console.log("Операция завершена (успех или ошибка)");
});
```

### **Цепочки промисов (Promise chaining)**

Каждый `.then()` возвращает новый промис, поэтому можно строить “цепочки”:

```js
promise
	.then((result) => {
		console.log(result);
		return "Следующий шаг";
	})
	.then((data) => {
		console.log(data); // "Следующий шаг"
		// Можно вернуть ещё один промис
		return fetch("/api/some-data");
	})
	.then((response) => response.json())
	.catch((error) => {
		console.error("Ошибка на любом этапе:", error);
	})
	.finally(() => {
		console.log("Всегда выполняется");
	});
```

- Если внутри `then` возвращаем значение — следующий `then` получит его.
- Если возвращаем новый промис — цепочка будет ждать его завершения.
- Если ошибка — сразу прыгнет в ближайший `catch`.

### **Статические методы Promise**

### 1. `Promise.all(iterable)`

- Принимает массив (или любой iterable) промисов.
- **Запускает все промисы одновременно**.
- Возвращает **один новый промис**, который:
  - _Fulfilled_: когда **все** промисы завершились успешно, результат — массив результатов.
  - _Rejected_: если хотя бы один промис с ошибкой — сразу ошибка этого промиса.

```js
Promise.all([p1, p2, p3])
	.then(([res1, res2, res3]) => {
		/* все успешно */
	})
	.catch((err) => {
		/* хотя бы один с ошибкой */
	});
```

### 2. `Promise.race(iterable)`

- Принимает массив промисов.
- Возвращает **промис**, который выполнится/отклонится сразу, как только первый из переданных промисов завершится (не важно, с успехом или ошибкой).

```js
Promise.race([p1, p2, p3])
	.then((result) => {
		/* кто быстрее */
	})
	.catch((error) => {
		/* если первым завершился rejected */
	});
```

### 3. `Promise.allSettled(iterable)`

- Ждёт, когда **все промисы завершатся** (неважно, с ошибкой или успешно).
- Возвращает массив объектов-результатов `{status, value}` или `{status, reason}`.

```js
Promise.allSettled([p1, p2, p3]).then((results) => {
	// results: [{status: "fulfilled", value: ...}, {status: "rejected", reason: ...}, ...]
});
```

### 4. `Promise.any(iterable)`

- Ждёт, когда **первый промис завершится успешно** (fulfilled).
- Если все промисы с ошибкой — будет ошибка AggregateError.

```js
Promise.any([p1, p2, p3])
	.then((result) => {
		/* первый успешный */
	})
	.catch((errors) => {
		/* если все упали */
	});
```

---

<RelatedTopics
	:items="[
		{ title: 'Что такое замыкание', href: '/javascript/chto-takoe-zamykanie' },
		{ title: 'Event Bubbling', href: '/javascript/event-bubbling' },
		{ title: 'Event Loop', href: '/javascript/event-loop' },
	]"
/>

