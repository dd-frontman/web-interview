- Когда вы меняете реактивное состояние, Vue не обновляет DOM сразу. Вместо этого он **группирует несколько изменений** и применяет их **в одном обновлении**. Это помогает избежать лишних перерисовок и экономит ресурсы.:contentReference[oaicite:0]{index=0}
- Каждое изменение добавляет **Watchers** в очередь. Vue запускает `flushSchedulerQueue` на **следующем тике** (асинхронно через microtask), и выполняет все накопленные обновления одним пакетом.:contentReference[oaicite:1]{index=1}

---

## `nextTick()`: что это и почему важно

- `nextTick()` — это утилита, которая позволяет выполнить код **после того, как Vue завершил перерендер DOM**, но **до следующего рендера браузера**.:contentReference[oaicite:2]{index=2}
- В отличие от `setTimeout(..., 0)`, callback у `nextTick()` запускается **раньше**, прямо после завершения обновления DOM, а не после рендера.:contentReference[oaicite:3]{index=3}

---

## Когда нужно испозовать `nextTick()`

- **После мутации данных**, чтобы обращаться к актуальному DOM (например, scroll, focus).:contentReference[oaicite:4]{index=4}
- При тестировании: чтобы assertion выполнялся после того, как DOM обновился.:contentReference[oaicite:5]{index=5}
- В хуках вроде `onMounted()` или `onUpdated()`, когда нужно работать с физической структурой DOM.:contentReference[oaicite:6]{index=6}

---

## Примеры

```vue
<script setup>
import { ref, nextTick } from "vue";

const count = ref(0);
const el = ref(null);

function increment() {
	count.value++;
	console.log("до nextTick:", el.value?.textContent); // всё ещё старое значение

	nextTick(() => {
		console.log("после nextTick:", el.value?.textContent); // уже обновлённое
	});
}
</script>

<template>
	<div ref="el">{{ count }}</div>
	<button @click="increment">+</button>
</template>
```
