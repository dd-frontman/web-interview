## 1. Краткое объяснение

Vue-компилятор преобразует содержимое `<template>` в **render-функцию**. При этом он заранее отмечает статичные и динамичные части шаблона и может **tree-shake** — удалять неиспользуемые фичи из итогового бандла.

---

## 2. Подробное объяснение

###  Как это работает

1. **Парсинг → AST**  
   Сначала шаблон преобразуется в AST (абстрактное синтаксическое дерево), описывающее структуру HTML-шаблона с директивами и выражениями.

2. **Оптимизация: статический vs динамический**  
   AST анализируется на предмет статичных узлов — таких, что не меняются при рендере (например, обычный `<div>Static text</div>`). Такие узлы помечаются как статичные и позже выносятся в отдельные функции, чтобы они не перерендеривались постоянно.

3. **Генерация render-функции**  
   На основе оптимизированного AST генерируется render-функция — JavaScript-код, который создаёт VNode-дерево. Статичные части используют **hoisting** (вынесение), а динамичные — обновляются при изменении реактивных данных.

4. **Tree-shaking**  
   Vue-компилятор генерирует код так, что импорты из Vue-runtime делаются **только для реально используемых функций и директив**. Если, скажем, в шаблоне не используется `<Transition>` или `v-show`, то соответствующие части Vue-runtime не попадут в итоговый бандл.  
   Это работает благодаря модульной архитектуре Vue 3, где функции и хелперы экспортируются как ES-модули, что позволяет сборщику (Webpack, Rollup, Vite) удалить неиспользуемый код.

###  Почему это важно

- **Быстрее работа UI**: статичные части рендерятся один раз, а динамичные — обновляются минимально.  
- **Меньший объём кода**: ненужные фичи отсутствуют в продакшн-бандле.  
- **Гибкость**: вы получаете все удобства шаблонов, плюс контроль через render-функции, и при этом ничего лишнего не “весит” в приложении.

###  Распространённые ошибки

- **Ожидание tree-shaking на уровне шаблона**, как при динамических выражениях — это не работает. Tree-shaking работает на уровне **скриптов и модулей**, а не непосредственно в шаблоне.  
- **CSS-стили из неиспользуемых компонентов** могут всё равно попадать в сборку — по умолчанию Vue SFC вставляет стили даже из неиспользуемых `.vue`, если не настроены `sideEffects`. Это особенность CSS, а не шаблонного компилятора.

---

## 3. Примеры кода

###  Пример ручного компилятора (Vue 2)

```js
// npm install vue-template-compiler
const compiler = require('vue-template-compiler');

const res = compiler.compile('<div><p>{{ msg }}</p><span>Static!</span></div>');

console.log(res.render); 
// — это строка с JS кодом,
// например: "with(this){return _c('div',[_c('p',[_v(_s(msg))]),_v('Static!')])}"

console.log(res.staticRenderFns); 
// — массив строк с JS кодом для статичных частичных деревьев
```
Это пример `compile()` в Vue 2: из шаблона получаются `render` + `staticRenderFns`.
### Статическая оптимизация (Vue 3)
В Vue 3 статичные узлы выносятся в hoisted переменные:
```js
const _hoisted_1 = /*#__PURE__*/createVNode('span', null, 'Static!');
export function render(_ctx, _cache) {
  return (openBlock(), createBlock('div', null, [
    createVNode('p', null, toDisplayString(_ctx.msg), 1 /* TEXT */),
    _hoisted_1
  ]));
}
```
Статичный `<span>` сохраняется в `_hoisted_1`, а динамичный `<p>` пересоздаётся при изменении `msg`.

### Tree-shaking примеры
Если шаблон не использует `<transition>` или `v-show`, код для них не будет сгенерирован и не попадёт в бандл:
```js
// только при использовании `<transition>`
// import { Transition, applyDirectives, vShow } from 'vue'
```
## 5. Чит-шит шпаргалка (таблица)

| Стадия компиляции    | Что происходит                                                              |
| -------------------- | --------------------------------------------------------------------------- |
| **Парсинг → AST**    | Генерируется абстрактное синтаксическое дерево шаблона                      |
| **Оптимизация**      | Выделяются статичные и динамичные узлы, static hoisting                     |
| **Генерация render** | Формируется JavaScript-рендер, создающий VNode                              |
| **Tree-shaking**     | Импортируются только использованные хелперы/директивы, экономия бандла      |
| **Отдельно (CSS)**   | Vue SFC вставляет CSS даже из неиспользуемых компонентов, нужен sideEffects |

