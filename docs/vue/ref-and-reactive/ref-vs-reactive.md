## 1) Полная (глубокая) реактивность

- **`reactive(obj)`** — оборачивает объект/массив **Proxy**. Трекаются `get/has/iterate`, а мутации вызывают перерисовку. Вложенные объекты «реактивизируются» лениво и тоже становятся прокси.
- **`ref(value)`** — «реактивная ячейка» со свойством `.value`. Если внутрь положить **объект/массив**, он будет сделан **глубоко реактивным** (внутри — тот же `reactive`), поэтому изменения на вложенных уровнях тоже отслеживаются.

**Ментальная модель:**

- `reactive` — «реактивный объект»: Vue перехватывает доступ к полям и их изменения.
- `ref` — «реактивная коробочка»: чтение/запись `.value` — единая точка track/trigger; если `.value` — объект, его содержимое тоже глубоко реактивно.

---

## 2) «Плоская» (shallow) реактивность

Иногда глубокий трекинг избыточен (большие структуры, внешние сторы).

- **`shallowRef(value)`** — реактивность **только на уровне `.value`**. Глубокие изменения **не** отслеживаются. Чтобы отразить их в UI, замените ссылку (`.value = новыйОбъект`) **или** вручную «пни́те» подписчиков через **`triggerRef()`**.
- **`shallowReactive(obj)`** — реактивна **только верхушка**: `obj.foo = ...` отследится, но `obj.nested.x++` — нет (если `nested` — обычный объект). Вложенные структуры остаются «как есть».

**Куда применять:**

- `shallowRef` — для тяжёлых/внешних структур и интеграций (минимум оверхеда; контролируете обновления заменой ссылки/`triggerRef`).
- `shallowReactive` — когда важно отслеживать только верхний слой свойств, а вложенные не критичны.

---

## 3) Автораспаковка (unwrapping) и деструктуризация

- В **шаблонах** `ref` разворачивается автоматически (можно писать `count` вместо `count.value`). В JS — нужна `.value`.
- `reactive` при обычной **деструктуризации** теряет связь с реактивностью полей (вы вытаскиваете «голые» значения). Используйте `toRef()` / `toRefs()` для сохранения реактивности свойств.

---

## 4) Диагностика и отладка

- **Хуки отслеживания в компонентах:** `onRenderTracked` (что было затрекано при рендере) и `onRenderTriggered` (что именно триггернуло повторный рендер).
- **Хуки дебага в наблюдателях:** передайте `onTrack`/`onTrigger` в `watch`/`watchEffect`/`computed`, чтобы логировать события трекинга/триггера.
- В dev-режиме удобно ставить `debugger` в этих колбэках и смотреть `DebuggerEvent` (ключ, тип операции, цель и т.д.).

---

## 5) Практические паттерны

- **Большие/иммутабельные структуры:** храните в `shallowRef`, заменяйте ссылку `.value = next`, чтобы избежать глубокой реактивизации огромных деревьев.
- **Смешанные кейсы:** если нужно иногда «копать» глубоко, а иногда — дешёво обновлять, комбинируйте: локально используйте `shallowRef`, а для конкретных веток — вручную создавайте `reactive`/`ref`.
- **Редкие мутации глубоко внутри `shallowRef`:** после изменения — `triggerRef(myShallow)`.

---

## 6) Мини-пример

```ts
import { shallowRef, triggerRef, reactive, toRefs, onRenderTracked, onRenderTriggered } from "vue";

// 1) Большая структура — только на ссылке
const cache = shallowRef<{ items: any[] }>({ items: [] });

// Глубокая мутация НЕ вызовет обновление:
cache.value.items.push({ id: 1 });
// Явно «пнуть» подписчиков:
triggerRef(cache);

// 2) Полная реактивность объекта
const state = reactive({ user: { name: "Alice" }, count: 0 });
state.user.name = "Bob"; // отследится
state.count++; // тоже отследится

// 3) Сохранить реактивность при деструктуризации
const { user, count } = toRefs(state);
// user.value.name и count.value — реактивны

// 4) Отладка: что трекается/триггерится рендером
onRenderTracked((e) => {
	// e.key / e.type ('get' | 'has' | 'iterate') и т.д.
	console.log("Tracked:", e);
});
onRenderTriggered((e) => {
	console.log("Triggered:", e);
});
```

# Vue 3: Таблица-шпаргалка по реактивности

Ниже представлена аккуратная Markdown-таблица с ключевыми API Vue 3 и их характеристиками:

| API                     | Глубина реактивности                 | Особенности                                                                                                                                                                              |
| ----------------------- | ------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `reactive(obj)`         | **Глубокая**                         | Создаёт Proxy, обеспечивает глубокую реактивность. `ref` внутри unwrap’ится автоматически.                                                         |
| `shallowReactive(obj)`  | **Только верхний уровень**           | Реактивны только свойства первого уровня. Вложенные объекты остаются «свободными», `ref` внутри **не unwrap**’ится.                                |
| `ref(value)`            | **Глубокая**, если `.value` — объект | Реактивная ячейка `.value`. Если передаётся объект, Vue автоматически оборачивает его через `reactive()`.                                          |
| `shallowRef(value)`     | **Только `.value`**                  | Трекинг только при смене `.value`, вложенные изменения игнорируются — подходит для больших/внешних структур.                                       |
| `triggerRef(ref)`       | —                                    | Принудительно активирует реакцию для `shallowRef`, особенно после глубокой мутации.                                                                |
| `onTrack` / `onTrigger` | — (debug)                            | Хуки для отладки: показывают, что отслеживается (`onTrack`) и что триггерит реакцию (`onTrigger`) — работают в `computed`, `watch`, `watchEffect`. |
| `shallowReadonly(obj)`  | **Только верхний уровень**           | Аналог `readonly()`, делает только верхний уровень readonly, вложенные доступны.                                                                   |
| `readonly(obj)`         | **Глубокая**                         | Делает объект и все вложенные свойства доступными только для чтения. (сравнительно с `shallowReadonly`)                                            |
| `toRaw(proxy)`          | —                                    | Возвращает оригинальный объект, из-под Proxy reactive/readonly/shallowReactive. Осторожно использовать.                                            |
| `markRaw(obj)`          | —                                    | От метки Vue: объект не будет проксирован, остаётся "сырым". Полезно для 3rd-party, классов, UI-элементов.                                         |

---

## Комментарии к API

- **`reactive()`** — выбирайте для работы с глубокой, сложной структурой, особенно если нужны мутации свойств.
- **`shallowReactive()`**, **`shallowRef()`** — минимизируйте накладные расходы реактивности при работе с большими или внешними структурами.
- **`ref()`** — универсален: примитивы, объекты, массивы; `.value` — точка подписки. Вложенные объекты станут reactive.
- **`triggerRef()`** — вручную инициирует реактивный ререндер для `shallowRef`.
- **`onTrack` / `onTrigger`** — отличные инструменты отладки реактивности в dev-режиме.
- **`readonly()`**, **`shallowReadonly()`** — для защиты данных от изменений (универсально vs по-уровнево).
- **`toRaw()`** и **`markRaw()`** — низкоуровневые escape-hatch API, которые требуют аккуратности.

---

Если потребуется, могу дополнить таблицу примерами кода, сравнениями производительности, use-case’ами для `markRaw`, или включить `effectScope()` и lifecycle-хуки `onRenderTracked/onRenderTriggered`.
:

---

> [!tip] Связанные темы
>
> - [reactive](/vue/ref-and-reactive/reactive)
> - [Реактивность во Vue3](/vue/ref-and-reactive/reaktivnost-vo-vue3)
> - [shallowReactive](/vue/ref-and-reactive/shallowreactive)

