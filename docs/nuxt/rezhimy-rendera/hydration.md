---
title: "Hydration"
description: "1. SSR: сервер отрендерил компонент <button>Нажми</button> и отдал HTML."
tags:
  - "nuxt"
  - "hydration"
updatedAt: "2026-02-16"
---
## 1) Простое объяснение

**Hydration** — это процесс, когда браузер **«оживляет» HTML, сгенерированный на сервере (SSR)**, добавляя к нему JavaScript-логику (обработчики событий, реактивность, состояние).

Иначе говоря:

- Сервер отдаёт **готовый HTML** (для SEO и быстрого первого отображения).
- Браузер рисует этот HTML сразу.
- Потом загружается JS-бандл → и Vue/React **«связывает» существующую разметку с виртуальным DOM**.
- В итоге элементы начинают реагировать на клики, обновления состояния и т. д.

---

## 2) Как это выглядит пошагово

1. **SSR**: сервер отрендерил компонент `<button>Нажми</button>` и отдал HTML.
2. **Браузер** показал кнопку, но пока без JS-событий (она «мертвая»).
3. **Hydration**: JS-фреймворк сравнивает HTML с виртуальной моделью компонента и «подключает» обработчики (`onClick`, `watchers`, реактивность).
4. Теперь кнопка «живая» — работает счётчик, меняется DOM при `setState`/`ref.value++`.

---

## 3) Пример в React

```tsx
// SSR: сервер отдаёт <button>Count: 0</button>
function Counter() {
	const [count, setCount] = React.useState(0);
	return <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>;
}
```

- На сервере рендерится HTML с `Count: 0`.
- В браузере React «гидрирует» элемент → кнопка начинает реагировать на клики.

---

## 4) Пример во Vue (Nuxt 3)

```vue
<script setup>
const count = ref(0);
</script>

<template>
	<button @click="count++">Count: {{ count }}</button>
</template>
```

- Сервер отдаёт: `<button>Count: 0</button>`.
- После гидрации Vue связывает HTML и реактивный `ref`.
- Теперь `@click` работает и UI обновляется.

---

## 5) Проблемы гидрации

- **Hydration mismatch** — когда HTML от сервера не совпадает с тем, что JS ожидает отрисовать:
  - разные данные на сервере и клиенте (например, `Date.now()` или `Math.random()` отдали разные значения).
  - условный рендеринг, который зависит от `window` или размера экрана (на сервере этих данных нет).
- Это вызывает **варнинги** или даже полную перерисовку узла.

### Как избегать:

- Избегать «недетерминированного» рендера (random, Date).
- Использовать `onMounted()` (Vue) или `useEffect()` (React), чтобы запускать «клиентскую» логику после гидрации.
- В Nuxt/Next — выносить только-клиентские части в динамические компоненты с `clientOnly`/`dynamic import { ssr: false }`.

---

## 6) Альтернативы и улучшения

- **Partial Hydration** → гидрировать только нужные части, а не всю страницу.
- **Streaming SSR** → сервер стримит куски HTML и гидрирует их по мере загрузки.
- **Islands Architecture** (Astro, Qwik) → вместо полной гидрации только отдельные «островки» получают JS.

---

# Шпаргалка

| Этап           | Что происходит                                                   |
| -------------- | ---------------------------------------------------------------- |
| SSR            | Сервер отдаёт готовый HTML                                       |
| Hydration      | JS связывает HTML с виртуальным DOM/реактивностью                |
| До гидрации    | Страница видна, но «мертвая» (без событий)                       |
| После гидрации | Элементы становятся интерактивными                               |
| Проблемы       | Hydration mismatch, двойной рендер                               |
| Решения        | Избегать nondeterministic кода, переносить в onMounted/useEffect |

---

<RelatedTopics
	:items="[
		{ title: 'ISR - Incremental Static Regeneration', href: '/nuxt/rezhimy-rendera/isr-incremental-static-regeneration' },
		{ title: 'Nitro', href: '/nuxt/nitro' },
		{ title: 'Nuxt vs Vue', href: '/nuxt/nuxt-vs-vue' },
	]"
/>
